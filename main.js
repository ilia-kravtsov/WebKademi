//                                    Виды комментариев: ---------------------------------------

/* Многострочный
   Комментарий */

// Однострочный комментарий       Комбинация клавиш для раскомментирования - ctrl + / 

//                                    Hello World JS!

console.log("Hello, World JS!")

//                                    Типы переменных: -----------------------------------------

//                                var       let      const

// переменную можно - 1. Объявлять! 
//                    var tin;
//                    2. Присваивать ей значение, после объявления:
//                    var tin;       
//                    tin = "der";
//                    3. Присваивать ей значение во время объявления: 
//                    var tin = "der";
//                    4. Обновлять! 
//                    var tin = "der";
//                        tin = "red"; 
//                    5. Повторно объявлять (переопределять) (так можно только с var):
//                    var tin = "der";
//                    var tin = "red";             

// Переменная должна быть сначала объявлена и только потом использована. программа читает код сверху вниз.
// Новый стандарт ES6 был утвержден в июне 2015 года.
// let - переменная
// const - константа

// Старый стандарт ES5
// var - переменная

//let - может менять значение во время работы программы

// let userName = "ilia";
// console.log(userName);

// userName = "maksim";
// console.log(userName);

// const - не может менять своё значение во время работы программы
// const yearOfBirth = 1999;

//                    const yearOfBirth = 1999;
//                    yearOfBirth = 2000;------ Ошибка!!!
// после ошибки консоль ничего не выводит, после ошибки программа не работает.
// проекты пишем на const, если понимаем что переменная будет меняться - меняем на let;
// c let мы можем просто объявить сразу несколько переменных не присваивая им значение;

// let name, v, p;
// а уже затем присвоить объявленным переменным значения:
// name = 1; 
// v = 2;
// p = 3;
// но можем и объявить и присвоить значение одной переменной сразу
// let tin = "der";
// c "const" мы не можем делать - строка вниз.
// const profession; - ошибка! так как при const нужно сразу присваивать значение.
// при объявлении сonst сразу нужно писать то значение, которое она должна содержать!

// верная запись - let userName = "ilia"; const userName = "oleg"; и никак иначе!

//                                        var
// в отличие от let и const, var имеет функциональную область видимости, а не блочную
// блок может быть функцией и не только!
// не рекомендуется к использованию
// var - может менять своё значение на протяжении работы программы!
// var - устаревший аналог let - но более гибкий.


//                                    Отличия var let const ------------------------------------
//                Отличие I
//
// область видимости var - ограничена функцией, (границы функции {...}) либо 
// глобальной областью видимости, если var находится вне функции.
// если речь идёт о
//
// var weight = 10;
// if (weight > 8) {
//    var kg = `Вес ${weight} кг`;  
//    console.log(kg)
// }
//
// если при этом вызвать переменную kg в браузере (в глобальной области видимости)
// то мы увидим значение переменной, потому что в данном случае var находится  
// не в функции а в блоке, а это значит что область ее видимости является глобальной.
//
// Ключевое отличие var от let и const - область видимости
// у let и const область видимости ограничена - не функцией (как у var), а Блоком!
// Блок - любой элемент с фигурными скобками, в том числе и Функция!
// поэтому если мы поменяем var на let:
//
// let weight = 10;
// if (weight > 8) {
//    let kg = `Вес ${weight} кг`;  
//    console.log(kg)
// }
//
// и попытаемся вызвать переменную kg из глобальной области видимости
// то такой переменной в ней не будет! потому что область видимости ограничена Блоком!
// то же самое относится к const!
// 
// итого Область видимости var - Функция
// Область видимости let and const - Блок
//
//                Отличие II
//
// с помощью let и const (в отличие от var) в пределах одной области видимости
// переменная может быть объявлена - только один раз!
//
// c var можно вот так:
// var user = "ilia";
// var user = "ilai";  --- oк ---
//
// c let так нельзя!
//
// let user = "ilia";
// let user = "ilai";  --- Ошибка! ---
//
// Если мы используем let и хотим Обновить значение переменной, то:
//
// let user = "ilia";
//     user = "ilai";  --- oк ---
//
// Далее:
//
// let speed = 60;
// let shtraf = false;

// if (speed > 50) {
// let shtraf = true;  
// }
//
// в этом случае при вызове переменной shtraf в глобальной области видимости 
// значение будет - false, потому что область видимости переменной let - блок,
// в данном случае Блок if {...}
// let shtraf = false; и let shtraf = true; - это две разные переменные 
// в двух разных областях видимости
// если сделать тоже самое с помощью var - значение переменной shtraf - true.
//
//                 Отличие III
//
// чем отличается let от const?
// 
// переменные объявленные с помощью let - можно обновлять!
//
// let speed = 60;
//     speed = 50;    --- oк ----
//
// переменные объявленные с помощью const - нельзя обновлять! 
// (Условие не относится к свойствам объекта) 
//
// const car = "tesla";
//       car = "BMW";   --- Ошибка! ---
//
// Условие не относится к свойствам объекта:
//
// const car {
//       name: "tesla",
//       color: "red"  
// };
//
// если я хочу обновить свойство name:
//
// const car {
//       name: "BMV",
//       color: "red"  
// };                   --- Ошибка! ---
// потому что таким образом мы переопределяем переменную созданную с помощью const!
//
// Но мы можем обновлять отдельные свойства переменной const:
//
// const car {
//       name: "tesla",
//       color: "red"  
// }; 
//
// car.name = "BMW";   --- ок ---
// 
// если мы хотим запретить обновлять свойства объекта, то:
// используем метод: 
//
// const car {
//       name: "tesla",
//       color: "red"  
// }; 
//
// Object.freeze(car)
//
// car.name = "BMW";  --- car = "tesla" ---
//
// Итог:
//
// var - не используем, но понимаем как работает, для дальнейшей работы с legacy
//
// const - используем всегда
//
// let - используем когда понимаем что переменную в будущем потребуется обновить.
//
//
//                                Типы Данных: -------------------------------------------------
//       Тип I Строка (String)
//
// let username = "ilia";
// использование после знака присваивания "" или '' означает тип данных - строка.
// Строка - это одно слово, фраза, предложение, абзац, книга, любой текст в "" или ''.
// 
//       Тип II Число (Number)
//
// let age = 30; 
// Пишется без кавычек
// Если число записано в кавычках - это строка
// let age = "30"; - строка (другая подсветка)
// 
//       Тип III Логические значения true/false (Boolean)
// 
// let u = true;
//
//       Динамическая типизация
// 
// Заключается в отсутствии обязательной необходимости присваивать значение переменной 
// при её объявлении и тем самым указывать какой тип данных она будет содержать,
// а так же в возможности обновлять переменную после ее объявления
// в том числе меняя уже указанный тип данных.
//
// let a = "string"; (строка)
//     a = 30;       (Число)
//     a = false;    (Boolean)
//
// Делать так можно, но не нужно. Лучше создать новую переменную.
//
//        Naming
//
// Нужно присваивать понятные для других программистов имена переменных.
//
// let u = "James";         - плохой пример
// let userName = "James"; - хороший пример
//
//       Тип IV null 
// null - ничего, пусто, значение неизвестно.
//
// Используется если хочу сбросить значение переменной.
//
   let age = 30;
       age = null;
//
//        Тип V undefined (неопределено)
//
// Означает что значение не было присвоено или значение не определено:
//
   let a;         // - undefined
   console.log(a)
//
// так когда не указана что именно будет возвращать Функция
// она тоже будет возвращать undefined
// 
// либо когда производится поиск элемента на странице но он не был найден
//
//        Оператор typeof - позволяет определить тип переменной
// 
   const someName = "Bob";
   console.log(typeof "Bob");
//
// Ответ - string. etc.
//
//        Тип VI BigInt
//
// Встроенный объект который позволяет нам создавать большие числа.
// Максимальное число которое мы можем использовать в JS типа Number
// Мы можем получить обратившись к объекту number и его свойству
// MAX_SAFE_INTEGER

   let Number = "301231232131313123";
   console.log(Number.MAX_SAFE_INTEGER);
   console.log(234234234242424234234242424)
   
// в консоли появится - 2.3423423424242423e+26 c таким мы уже работать не можем поэтому BigInt
// если нужно будет работать с большим числом чем number то нужно будет использовать BigInt
//
// Чтобы привести число к BigInt надо приписать n в конце числа

   let Numb = "301231232131313123";
   console.log(Numb.MAX_SAFE_INTEGER);
   console.log(1231231231234534675686789n) 

// в консоли появится - 1231231231234534675686789n с такими числами мы уже можем работать
// но при работе такие числа могут работать только друг с другом.
//
//          Тип VII Symbol
//
// Используется чтобы создать уникальные значения для идентификаторов
// для имён свойств в объектах
// Символ - это уникальное примитивное значение
// Позволяет добавлять уникальные свойства объекту с уверенностью что
// Это самое новое свойство:
// не перезапишет никакое другое свойство которое уже существует у объекта.
// 
// Т.е. если нужно добавить в объект какое-то значение так чтобы его свойства никак
// не влияли на те свойства значений который уже существуют - symbol
// Либо чтобы оно не участвовало в переборе свойств этого объекта
//
//          Итого Типы данных существующие в JS
//
// Number
// String
// Boolean Булевый тип данных
// Null
// Undefined
// Object
// arrays
//
// Symbol
// BigIne
//
//                                     Операторы сравнения и условия ---------------------------
//
// >    <     >=    <=
// =   присваивание
// ==  не строгое сравнение
// === строгое сравнение
// !=  не строгое неравнество
// !== строгое неравенство

   console.log(10 > 5);  //true
   console.log(20 > 50); //false

// сначала выполняется операция сравнения
// console.log(true or false); и только потом выводится в консоль

//   let result = 10 > 5; // true
//  console.log(result);

// равно ли 10 5 -и 10 == 5

   let result = 10 == 5;
   console.log(result); // false

// происходит сравнение в скобках 10 не равно 5-и
// let result = false
// console.log(result); - видим false
//
// если мы сравним пятёрку в виде строки с пятёркой в виде числа
//
//       Динамическое приведение типов

   console.log('5' == 5); // --- true ---

// если мы сделаем не строгое сравнение то true

   console.log('5' === 5); // --- false ---

// если строгое === то false, т.е. в этом случае он будет сравнивать не только значение но еще и
// типы и так как к единому типу он привести не сможет 
// то при строгом сравнении выдаст false, так как строка не равна числу

// что произойдет если мы ошиблись и указали вместо == и === - =
   let number = 5;
   if (number = 10) {
      console.log(1111);
      console.log(number);
   } // --- вернёт нам true (10) ---

//                   Условия  
//
//        if (условие) {
//        // код который будет выполнен если условие верно
//       }

//        else {
//        // код который будет выполнен если условие не верно
//       }
//
   const time = 20;

   if (time < 12) {
      console.log("Доброе утро");
   }

   else if  (time >= 12 && time < 18) {                     // && - логический оператор И
      console.log("Добрый день");                // когда и 1 и 2 условие должны быть истиными
   } // else if - дополнительное условие

   else {
      console.log("Добрый вечер");
   }
//
//                    Логические операторы
//
//  && - and логическое И
//  || - логическое ИЛИ
//  !true - логическое НЕ
//
//                    Тернарный оператор
//
// Т.О. - это короткая форма записи Условия, применяется:
// для сокращения кода, для улучшения читаемости кода

if (10 < 12) {
   console.log("Условие верно");
} else {
   console.log("Условие неверно");
}

//  (условие) ?        (условие верно)       : (условие не верно);

     10 < 12 ? console.log("Условие верно") : console.log("Условие не верно");

//
// 1 Пишем условие затем ставим ? что значит что мы будем писать тернарный оператор
// Далее мы пишем выражение которое выполнется если условие верно : 
// и выражение которое выполнится если условие не верно ; то есть:

// Так же тернарный оператор может возвращать значения чтобы мы их записывали в переменные
//
// на if else пример будет выглядеть так:

   // let greeting;
   // let timez = 10;

   // if (10 < 12) {
   //    greeting = 'Доброе утро';
   // } else {
   //    greeting = 'Добрый день';
   // }

   // console.log(greeting);

// на Тернарном операторе этот же пример будет выглядеть так:

   let timez = 10;
//   переменная    условие   ?  true         :   false      ;
   let greeting = timez < 12 ? 'Добрый утро' : 'Добрый день';
   console.log(greeting);

// т.е. переменная может быть равно условию и true или false после него.
//
//
//                     Конкатенация строк и шаблонные строки.
//
// Конкатенация - соеднинение. Используется для соединения двух строк в одну (сложение строк).
//
   let greet = "Hi ilia! ";
   let howau = "How are you?";

   let hello = greet + howau;
   console.log(hello);

// Практический пример конкатенации:

//    const userName = "ilia";
//    console.log('Привет ' + userName + ' how are u?');

//    Шаблонные строки и интерполяция

//    console.log(`Привет, ${userName} ! How are u?`);

//
//                                  Функции
//
// Есть сайт на всех страницах которого мы приветствуем пользователя,
// то есть код выполняет одно и тоже действие но описан в разных местах.
// Если необходимо изменить приветствие придётся изменять его в каждом приветствии на сайте.
// 
// Одно действие участвующее в разных местах кода
// должно быть описано один раз в одном месте для более удобного его изменения в дальнейшем
// для этого и нужны функции...
//
//            Принцип dry - don't repeat yourself
//
//
//   function ключевое слово, пробел, имя функции (стоит называть глаголом,
//   так, чтобы это было действие и было понятно что по этому действию будет происходить) 
//   после имени круглые скобки (они нужны для объявления параметров функции) пробел {фигурные скобки}
//   {} - это блок кода который будет выполняться когда функция будет запускаться, 
//   действие функции будет описано внутри этих фигурных скобок.
// 

//            Объявление функции

//    function sayHi() {
//    console.log('hello mr. smith');
//    }

// Чтобы запустить функцию нужно, после ее описания обратиться к имени + ();

//            Вызов функции

//   sayHi(); - () возле имени функции это вызов функции, т.о. запускаем её на выполнение.

// Мы можем вызывать функцию много раз 
// sayHi();
// sayHi();
// sayHi();
// sayHi();
// sayHi();
// sayHi();
// sayHi();
// sayHi(); - сколько угодно раз везде отработает её код

// При необходимости изменить что-либо, достаточно изменить это между {} и это изменится во всех ее вариантах
//
//            function declaration - объявление функции.

//   function sayHi() {
//   console.log('hello mr. smith');
//   }

//            function expression - функциональное выражение
// 
//    Записываем функцию в присваемое значение переменной.

   let sayHi = function() {
       console.log("Привет");
   };

   sayHi();
// после ключевого слова function нет имени. Для function Expression допускается его отсутствие.
// function expression можно использовать с let var const

//        Различия function declaration и function expression
//
// Когда мы объявляем функцию через function declaration мы можем вызывать эту функцию до того момента 
// как она была объявлена в коде
// 
// Когда речь идёт о переменной а не о функции, то
// Переменная должна быть сначала объявлена и только потом использована. программа читает код сверху вниз.
//
// но js читает код из файла 2 раза, читает 1 раз запоминает какие были объявлены переменные, но
// ещё не присваивает какие есть значения, просто формирует список того какие переменные есть
// и потом запускает программу на выполнение (чтение 2 раз) и  только в этот момент записывается значение 
// в объявленную переменную
// и когда читает код второй раз запускает код на выполнение.
//
// Поэтому когда мы используем function declaration мы можем 
// Вызвать функцию до того как она была объявлена
// Пример

// sayHi();

// function sayHi() {
//   alert('Привет');
// }

// при первом чтении js видит какие объявлены переменные и какие функции объявлены через 
// function declaration и эти функции он считывает полностью именно поэтому мы можем запустить 
// sayHi до того как она описана в коде

// + function declaration - код короче, лаконичнее.
// + fd мы можем описать сначала работу программы а ниже описать те функции которые нам нужны 
// т.e. разделение труда

// Когда мы используем function expression мы не можем вызвать функцию перед тем как мы её описали

// sayHi(); --- Ошибка! ---

// const sayHi = function() {
//       console.log('привет');           
// }

// + fe - если функция где-то вызывается значит она объявлена где-то выше (более строгий подход)

//                         Параметры и аргументы для функции

// Параметр это то значение которое функция будет принимать в себя на запуске
// и это значение она будет использовать внутри себя для работы функции.
   
   function hi(name) {
      console.log(`Привет, ${name} ! How are u?`);
   }

   hi('ilia');
// в данном случае параметром является "name" объявлять переменную name - не нужно
// name - параметр
// ilia - аргумент! т.е. когда мы вызываем функцию место параметра занимает аргумент.

// можем вызывать функцию несколько раз и каждый раз передавать в функцию новое значение
   hi('ivan');
   hi('igor');

// в данных случаях выше мы создавали функцию которая что-то выводит в консоль
// return - это когда функция после вывода возвращает нам какое-то значение

//                              Return

// a and b - are some numbers
// a and b - are parametrs
// 10 and 15 - are arguments
// аргументы становятся на места параметров - соответственно

// function summ(a, b) {
//     const result = a + b; 
//     console.log(result);
// }

// summ(10, 15); 

// но если вызвать функцию summ в консоли то мы увидим undefined 
// по умолчанию любая функция возвращает undefined если не определено что именно она должна возвращать
// т.е. в данный момент функция выводит значение в консоль, но ничего не возвращает

// для того чтобы функция возвращала значение используется return

//  function summ(a, b) {
//      const result = a + b; 
//      return result;
//  }

//  summ(10, 15); 

// в данный момент в консоли высвечивается значение 25, но не возвращается, потому что пока некуда)
// создаем новую переменную чтобы результату было куда возвращаться

//  function summ(a, b) {
//      const result = a + b; 
//      return result;
//  }

//  let res = summ(10, 15); 

//  console.log(res);  и выведем res в консоль и увидим там 25

// значение возвращается именно на место вызова функции и затем оно записывается в переменую res

//  function summ(a, b) {
//    console.log("start");    --- старт в консоли видим
//    const result = a + b; 
//    return result;           --- как только функция встретила return дальше ничего не происходит
//    console.log("finish");   --- финиш уже в консоли не видим после return код никогда не будет достигнут
// }   


// всё что после return в функции - не сработает

//                            Функции как аргумент

   // function summ(a, b) {
   //    const result = a + b; 
   //    return result;
   // }

// код выше можно сократить

// function summ(a, b) {
//       return a + b;
// }

// мы можем передавать функции как аргумент в другие функции
// Пример:

// let res = summ(10, 15);
// console.log(res);

// в консоль можно сразу передать функцию

// console.log(summ(10, 15));

// в данном случае js сначала видит summ(10, 15) смотрит на значения в скобках и производит вычисление
// и только после вычисления выводит в консоль лог полученный результат

// Пример посложнее

// function summ(a, b) {
//        return a + b;
//  }

// const resultss = summ(summ(15, 15), summ(20, 20))
// console.log(resultss);

// в консоли 70. механизм работы:
// интерпретатор идёт сверху вниз, находит переменную resultss видит что она равна вызову функции summ
// смотрит какой первый аргумент, первым аргументом тоже является вызов функции summ
// поэтому сначала выполняется первый аргумент summ с результатом в 30
// 30 возвращается в return если бы в функции не было return а например вывод в консоль то
// вернулось бы значение undefined и на том бы и закончилось)
// после того как в resultss возвращается 30, выполняется второй аргумент summ c результатом в 40
// после этого получаем const resultss = summ(30, 40) и функция запускается еще раз 
// и в итоге получаем 70
// таким образом функции могут передаваться в другие функции в качестве аргументов

// Пример еще сложнее
// когда мы передаем функцию в качестве аргумента в другую функцию и она будет запущена
// в данном случае ниже функция do принимает в качестве аргумента другую функцию
// и мы предполагаем что ту функцию func которую мы передаем в качестве аргумента (или параметра?) 
// что мы запустим ее в этой же функции

function summ(a, b) {
           return a + b;
     }

function diff(a, b) {
      return a - b;
}

function doSomething(func) {    
   let x = 10;
   let y = 15;
   let resul = func(x, y);
   console.log(resul);
}                           // the same      // function doSomething(func) {    
                                             //    let resul = func(10, 15);
                                             //    console.log(resul);                                             
 doSomething(summ);
 doSomething(diff);

// что произошло выше
// doSomething вызывает функцию summ которое приходит в func
// таким образом получается call back 
// функция которая будет вызвана где-то внутри функции после определенных действий
// то есть функция обратного вызова которую мы вызовем позже другой функцией
// 
// вызываем doSomething которое принимает значение summ summ делает работу внутри func
// после этого мы вызываем функцию которую мы туда передали func
// передали х и у запустили получили результат распечатали

// то есть каким-то способом из summ берется действие совершаемое между двумя числами 
// но значение этих числе подставляется из func

// мы запускаем doSomething в качестве аргумента передаем в нее функцию diff
// которая высчитывает разность значения подставляются из x and y 
// после чего получается -5 и это значение уже выводится в консоль

// внутри функции мы определяем параметром что мы будем принимать другую функцию
// и где - то внутри кода её запустим, она выполнится, вернёт результат и он уйдет в консоль

//                          Самовызывающаяся функция iife ES5

// iife i - immediately 
//      i - involved
//      f - function
//      e - expression

// iife - незамедлительно вызывающееся функциональное выражение (самовызывающаяся функция
// то есть функция которая вызывает саму себя) так же известная как 
// анонимная самовызывающаяся функция (имя функции можем не давать)

// итак в чём соль, изначально мы работая с функцией делаем что- то подобное 

// function say() {
//    console.log('hi');
// }

// say();

// Но мы можем этого не делать, а вызвать функцию сразу на месте её объявления без say();
// для этого необходимо обернуть её в круглые скобки, и т.о. мы создаём выражение ()
// в js () создают выражение мы делаем тоже самое, 
// сначала выполняется действие внутри скобок, потом за пределами скобок
// в js наше выражение в виде функции заключенной в () может быть запущено на выполнение 
// если мы допишем круглые скобки которые запустят нашу предыдущую функцию описанную в предыдущих ()
// в итоге наша функция запустится то есть мы сразу вызываем say не выписывая его отдельно
// пример

// (function say() {
//    console.log('hi');
// })();

// если у данной функции убрать say, то тогда в консоли будет то же hi но функция будет без имени
// то есть это будет анонимная самовызывающаяся функция
// такой приём может быть полезен когда мы хотим ограничить область видимости 
// если речь идет о старом стандарте ES5

// пример анонимной самовызывающейся функции и ее запуск с передачей в неё аргументов

(function () {
    console.log('hi');
 })();

(function sum (a, b) {
   console.log(a + b);   // превратим её в самовызывающуюся, имя пока оставляем.
})(10, 15); // для передачи значения, указываем значения во вторых () итог в консоли - 25

// если удалить sum в консоли так же будет 25 но функция уже будет анонимной
// убрав консоль лог поставив return и присвоим значение функции переменной 
// и затем выложив это в консоль мы получим те же 25

let resultt = (function sum (a, b) {
   return a + b;   
})(10, 15); 

console.log(resultt);

// когда функция возвращает что-то она возвращает это на место функции если 
// мы дополнительно ничего не указываем, поэтому в примере выше мы присваиваем 
// вернувшееся после let значение переменной resultt
// т.о. значение после вычисления функции возвращается в переменную resultt

//                                  Стрелочные функции ES6

//   function saidhi(name) {
//    console.log(`Привет, ${name} ! How are u?`);
// }

// пример выше это function declaration
// тоже самое в виде стрелочной функции
// создаём переменную и в неё записываем стрелочную функцию
// у стрелочной функции круглые скобки для параметра функции, затем => затем {} для блока кода
// который будет выполнятсья в стрелочной функции
// стрелочная функция работает так же как и обычная функция, но есть ньюансы

   // function saidhi(name) {
   //    console.log(`Привет, ${name} ! How are u?`);
   // }

   // saidhi('ilai'); 

   // const arrSayHi = (name) => {
   //    console.log(`Привет, ${name} ! How are u?`);
   // }

   // arrSayHi('ilai'); 

// в примере выше видим что у двух разных функций одинаковый результат в консоли
// стрелочная функция не имеет своего контекста и она заимствует контекст из области или
// ссылается на тот же контекст на который ссылается и область в которой она была объявлена
// функция не имеет своего this и ссылается на тот же контекст который имеется в области где 
// она была объявлена

//    Сокращение стрелочной функции

// если стрелочная функция, состоит из 1-й строки и это то значение которое она возвращает, то
// то мы можем не писать фигурные скобки, а сразу после стрелки продолжить писать строчку 
// функции, того что будет выполнятьсья

   // const arrSayHi = (name) => {
   //    console.log(`Привет, ${name} ! How are u?`);
   // }

   // arrSayHi('ilai'); 

   const arrSayHi = (name) => console.log(`Привет, ${name} ! How are u?`);
   arrSayHi('ilai'); 

   function ssum(a, b) {
      const resultat = a + b;
   }

// в виде стрелочной функции это будет вот так:

   // const sSum = (a, b) => {
   //    const resultats = a + b;
   //    return resultats;
   // };

// это можно сократить до 

   // const sSum = (a, b) => {
   //    return a + b;
   // };
 
// но так как у нас стрелочная функция и одна стррока, то можем сократить ещё

   const sSum = (a, b) => a + b;

// вызываем sSum

   const rez = sSum(10, 30);
   
   console.log(rez);



