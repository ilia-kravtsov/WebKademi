//                                    Виды комментариев: ---------------------------------------

/* Многострочный
   Комментарий */

// Однострочный комментарий       Комбинация клавиш для раскомментирования - ctrl + / 

//                                    Hello World JS!

console.log("Hello, World JS!")

//                                    Типы переменных: -----------------------------------------

//                                var       let      const

// переменную можно - 1. Объявлять! 
//                    var tin;
//                    2. Присваивать ей значение, после объявления:
//                    var tin;       
//                    tin = "der";
//                    3. Присваивать ей значение во время объявления: 
//                    var tin = "der";
//                    4. Обновлять! 
//                    var tin = "der";
//                        tin = "red"; 
//                    5. Повторно объявлять (переопределять) (так можно только с var):
//                    var tin = "der";
//                    var tin = "red";             

// Переменная должна быть сначала объявлена и только потом использована. программа читает код сверху вниз.
// Новый стандарт ES6 был утвержден в июне 2015 года.
// let - переменная
// const - константа

// Старый стандарт ES5
// var - переменная

//let - может менять значение во время работы программы

// let userName = "ilia";
// console.log(userName);

// userName = "maksim";
// console.log(userName);

// const - не может менять своё значение во время работы программы
// const yearOfBirth = 1999;

//                    const yearOfBirth = 1999;
//                    yearOfBirth = 2000;------ Ошибка!!!
// после ошибки консоль ничего не выводит, после ошибки программа не работает.
// проекты пишем на const, если понимаем что переменная будет меняться - меняем на let;
// c let мы можем просто объявить сразу несколько переменных не присваивая им значение;

// let name, v, p;
// а уже затем присвоить объявленным переменным значения:
// name = 1; 
// v = 2;
// p = 3;
// но можем и объявить и присвоить значение одной переменной сразу
// let tin = "der";
// c "const" мы не можем делать - строка вниз.
// const profession; - ошибка! так как при const нужно сразу присваивать значение.
// при объявлении сonst сразу нужно писать то значение, которое она должна содержать!

// верная запись - let userName = "ilia"; const userName = "oleg"; и никак иначе!

//                                        var
// в отличие от let и const, var имеет функциональную область видимости, а не блочную
// блок может быть функцией и не только!
// не рекомендуется к использованию
// var - может менять своё значение на протяжении работы программы!
// var - устаревший аналог let - но более гибкий.


//                                    Отличия var let const ------------------------------------
//                Отличие I
//
// область видимости var - ограничена функцией, (границы функции {...}) либо 
// глобальной областью видимости, если var находится вне функции.
// если речь идёт о
//
// var weight = 10;
// if (weight > 8) {
//    var kg = `Вес ${weight} кг`;  
//    console.log(kg)
// }
//
// если при этом вызвать переменную kg в браузере (в глобальной области видимости)
// то мы увидим значение переменной, потому что в данном случае var находится  
// не в функции а в блоке, а это значит что область ее видимости является глобальной.
//
// Ключевое отличие var от let и const - область видимости
// у let и const область видимости ограничена - не функцией (как у var), а Блоком!
// Блок - любой элемент с фигурными скобками, в том числе и Функция!
// поэтому если мы поменяем var на let:
//
// let weight = 10;
// if (weight > 8) {
//    let kg = `Вес ${weight} кг`;  
//    console.log(kg)
// }
//
// и попытаемся вызвать переменную kg из глобальной области видимости
// то такой переменной в ней не будет! потому что область видимости ограничена Блоком!
// то же самое относится к const!
// 
// итого Область видимости var - Функция
// Область видимости let and const - Блок
//
//                Отличие II
//
// с помощью let и const (в отличие от var) в пределах одной области видимости
// переменная может быть объявлена - только один раз!
//
// c var можно вот так:
// var user = "ilia";
// var user = "ilai";  --- oк ---
//
// c let так нельзя!
//
// let user = "ilia";
// let user = "ilai";  --- Ошибка! ---
//
// Если мы используем let и хотим Обновить значение переменной, то:
//
// let user = "ilia";
//     user = "ilai";  --- oк ---
//
// Далее:
//
// let speed = 60;
// let shtraf = false;

// if (speed > 50) {
// let shtraf = true;  
// }
//
// в этом случае при вызове переменной shtraf в глобальной области видимости 
// значение будет - false, потому что область видимости переменной let - блок,
// в данном случае Блок if {...}
// let shtraf = false; и let shtraf = true; - это две разные переменные 
// в двух разных областях видимости
// если сделать тоже самое с помощью var - значение переменной shtraf - true.
//
//                 Отличие III
//
// чем отличается let от const?
// 
// переменные объявленные с помощью let - можно обновлять!
//
// let speed = 60;
//     speed = 50;    --- oк ----
//
// переменные объявленные с помощью const - нельзя обновлять! 
// (Условие не относится к свойствам объекта) 
//
// const car = "tesla";
//       car = "BMW";   --- Ошибка! ---
//
// Условие не относится к свойствам объекта:
//
// const car {
//       name: "tesla",
//       color: "red"  
// };
//
// если я хочу обновить свойство name:
//
// const car {
//       name: "BMV",
//       color: "red"  
// };                   --- Ошибка! ---
// потому что таким образом мы переопределяем переменную созданную с помощью const!
//
// Но мы можем обновлять отдельные свойства переменной const:
//
// const car {
//       name: "tesla",
//       color: "red"  
// }; 
//
// car.name = "BMW";   --- ок ---
// 
// если мы хотим запретить обновлять свойства объекта, то:
// используем метод: 
//
// const car {
//       name: "tesla",
//       color: "red"  
// }; 
//
// Object.freeze(car)
//
// car.name = "BMW";  --- car = "tesla" ---
//
// Итог:
//
// var - не используем, но понимаем как работает, для дальнейшей работы с legacy
//
// const - используем всегда
//
// let - используем когда понимаем что переменную в будущем потребуется обновить.
//
//
//                                Типы Данных: -------------------------------------------------
//       Тип I Строка (String)
//
// let username = "ilia";
// использование после знака присваивания "" или '' означает тип данных - строка.
// Строка - это одно слово, фраза, предложение, абзац, книга, любой текст в "" или ''.
// 
//       Тип II Число (Number)
//
// let age = 30; 
// Пишется без кавычек
// Если число записано в кавычках - это строка
// let age = "30"; - строка (другая подсветка)
// 
//       Тип III Логические значения true/false (Boolean)
// 
// let u = true;
//
//       Динамическая типизация
// 
// Заключается в отсутствии обязательной необходимости присваивать значение переменной 
// при её объявлении и тем самым указывать какой тип данных она будет содержать,
// а так же в возможности обновлять переменную после ее объявления
// в том числе меняя уже указанный тип данных.
//
// let a = "string"; (строка)
//     a = 30;       (Число)
//     a = false;    (Boolean)
//
// Делать так можно, но не нужно. Лучше создать новую переменную.
//
//        Naming
//
// Нужно присваивать понятные для других программистов имена переменных.
//
// let u = "James";         - плохой пример
// let userName = "James"; - хороший пример
//
//       Тип IV null 
// null - ничего, пусто, значение неизвестно.
//
// Используется если хочу сбросить значение переменной.
//
   let age = 30;
       age = null;
//
//        Тип V undefined (неопределено)
//
// Означает что значение не было присвоено или значение не определено:
//
   let a;         // - undefined
   console.log(a)
//
// так когда не указана что именно будет возвращать Функция
// она тоже будет возвращать undefined
// 
// либо когда производится поиск элемента на странице но он не был найден
//
//        Оператор typeof - позволяет определить тип переменной
// 
   const someName = "Bob";
   console.log(typeof "Bob");
//
// Ответ - string. etc.
//
//        Тип VI BigInt
//
// Встроенный объект который позволяет нам создавать большие числа.
// Максимальное число которое мы можем использовать в JS типа Number
// Мы можем получить обратившись к объекту number и его свойству
// MAX_SAFE_INTEGER

   let Number = "301231232131313123";
   console.log(Number.MAX_SAFE_INTEGER);
   console.log(234234234242424234234242424)
   
// в консоли появится - 2.3423423424242423e+26 c таким мы уже работать не можем поэтому BigInt
// если нужно будет работать с большим числом чем number то нужно будет использовать BigInt
//
// Чтобы привести число к BigInt надо приписать n в конце числа

   let Numb = "301231232131313123";
   console.log(Numb.MAX_SAFE_INTEGER);
   console.log(1231231231234534675686789n) 

// в консоли появится - 1231231231234534675686789n с такими числами мы уже можем работать
// но при работе такие числа могут работать только друг с другом.
//
//          Тип VII Symbol
//
// Используется чтобы создать уникальные значения для идентификаторов
// для имён свойств в объектах
// Символ - это уникальное примитивное значение
// Позволяет добавлять уникальные свойства объекту с уверенностью что
// Это самое новое свойство:
// не перезапишет никакое другое свойство которое уже существует у объекта.
// 
// Т.е. если нужно добавить в объект какое-то значение так чтобы его свойства никак
// не влияли на те свойства значений который уже существуют - symbol
// Либо чтобы оно не участвовало в переборе свойств этого объекта
//
//          Итого Типы данных существующие в JS
//
// Number
// String
// Boolean Булевый тип данных
// Null
// Undefined
// Object
// arrays
//
// Symbol
// BigIne
//
//                                     Операторы сравнения и условия ---------------------------
//
// >    <     >=    <=
// =   присваивание
// ==  не строгое сравнение
// === строгое сравнение
// !=  не строгое неравнество
// !== строгое неравенство

   console.log(10 > 5);  //true
   console.log(20 > 50); //false

// сначала выполняется операция сравнения
// console.log(true or false); и только потом выводится в консоль

//   let result = 10 > 5; // true
//  console.log(result);

// равно ли 10 5 -и 10 == 5

   let result = 10 == 5;
   console.log(result); // false

// происходит сравнение в скобках 10 не равно 5-и
// let result = false
// console.log(result); - видим false
//
// если мы сравним пятёрку в виде строки с пятёркой в виде числа
//
//       Динамическое приведение типов

   console.log('5' == 5); // --- true ---

// если мы сделаем не строгое сравнение то true

   console.log('5' === 5); // --- false ---

// если строгое === то false, т.е. в этом случае он будет сравнивать не только значение но еще и
// типы и так как к единому типу он привести не сможет 
// то при строгом сравнении выдаст false, так как строка не равна числу

// что произойдет если мы ошиблись и указали вместо == и === - =
   let number = 5;
   if (number = 10) {
      console.log(1111);
      console.log(number);
   } // --- вернёт нам true (10) ---

//                   Условия  
//
//        if (условие) {
//        // код который будет выполнен если условие верно
//       }

//        else {
//        // код который будет выполнен если условие не верно
//       }
//
   const time = 20;

   if (time < 12) {
      console.log("Доброе утро");
   }

   else if  (time >= 12 && time < 18) {                     // && - логический оператор И
      console.log("Добрый день");                // когда и 1 и 2 условие должны быть истиными
   } // else if - дополнительное условие

   else {
      console.log("Добрый вечер");
   }
//
//                    Логические операторы
//
//  && - and логическое И
//  || - логическое ИЛИ
//  !true - логическое НЕ
//
//                    Тернарный оператор
//
// Т.О. - это короткая форма записи Условия, применяется:
// для сокращения кода, для улучшения читаемости кода

if (10 < 12) {
   console.log("Условие верно");
} else {
   console.log("Условие неверно");
}

//  (условие) ?        (условие верно)       : (условие не верно);

     10 < 12 ? console.log("Условие верно") : console.log("Условие не верно");

//
// 1 Пишем условие затем ставим ? что значит что мы будем писать тернарный оператор
// Далее мы пишем выражение которое выполнется если условие верно : 
// и выражение которое выполнится если условие не верно ; то есть:

// Так же тернарный оператор может возвращать значения чтобы мы их записывали в переменные
//
// на if else пример будет выглядеть так:

   // let greeting;
   // let timez = 10;

   // if (10 < 12) {
   //    greeting = 'Доброе утро';
   // } else {
   //    greeting = 'Добрый день';
   // }

   // console.log(greeting);

// на Тернарном операторе этот же пример будет выглядеть так:

   let timez = 10;
//   переменная    условие   ?  true         :   false      ;
   let greeting = timez < 12 ? 'Добрый утро' : 'Добрый день';
   console.log(greeting);

// т.е. переменная может быть равно условию и true или false после него.
//
//
//                     Конкатенация строк и шаблонные строки.
//
// Конкатенация - соеднинение. Используется для соединения двух строк в одну (сложение строк).
//
   let greet = "Hi ilia! ";
   let howau = "How are you?";

   let hello = greet + howau;
   console.log(hello);

// Практический пример конкатенации:

//    const userName = "ilia";
//    console.log('Привет ' + userName + ' how are u?');

//    Шаблонные строки и интерполяция

//    console.log(`Привет, ${userName} ! How are u?`);

//
//                                  Функции
//
// Есть сайт на всех страницах которого мы приветствуем пользователя,
// то есть код выполняет одно и тоже действие но описан в разных местах.
// Если необходимо изменить приветствие придётся изменять его в каждом приветствии на сайте.
// 
// Одно действие участвующее в разных местах кода
// должно быть описано один раз в одном месте для более удобного его изменения в дальнейшем
// для этого и нужны функции...
//
//            Принцип dry - don't repeat yourself
//
//
//   function ключевое слово, пробел, имя функции (стоит называть глаголом,
//   так, чтобы это было действие и было понятно что по этому действию будет происходить) 
//   после имени круглые скобки (они нужны для объявления параметров функции) пробел {фигурные скобки}
//   {} - это блок кода который будет выполняться когда функция будет запускаться, 
//   действие функции будет описано внутри этих фигурных скобок.
// 

//            Объявление функции

//    function sayHi() {
//    console.log('hello mr. smith');
//    }

// Чтобы запустить функцию нужно, после ее описания обратиться к имени + ();

//            Вызов функции

//   sayHi(); - () возле имени функции это вызов функции, т.о. запускаем её на выполнение.

// Мы можем вызывать функцию много раз 
// sayHi();
// sayHi();
// sayHi();
// sayHi();
// sayHi();
// sayHi();
// sayHi();
// sayHi(); - сколько угодно раз везде отработает её код

// При необходимости изменить что-либо, достаточно изменить это между {} и это изменится во всех ее вариантах
//
//            function declaration - объявление функции.

//   function sayHi() {
//   console.log('hello mr. smith');
//   }

//            function expression - функциональное выражение
// 
//    Записываем функцию в присваемое значение переменной.

   let sayHi = function() {
       console.log("Привет");
   };

   sayHi();
// после ключевого слова function нет имени. Для function Expression допускается его отсутствие.
// function expression можно использовать с let var const

//        Различия function declaration и function expression
//
// Когда мы объявляем функцию через function declaration мы можем вызывать эту функцию до того момента 
// как она была объявлена в коде
// 
// Когда речь идёт о переменной а не о функции, то
// Переменная должна быть сначала объявлена и только потом использована. программа читает код сверху вниз.
//
// но js читает код из файла 2 раза, читает 1 раз запоминает какие были объявлены переменные, но
// ещё не присваивает какие есть значения, просто формирует список того какие переменные есть
// и потом запускает программу на выполнение (чтение 2 раз) и  только в этот момент записывается значение 
// в объявленную переменную
// и когда читает код второй раз запускает код на выполнение.
//
// Поэтому когда мы используем function declaration мы можем 
// Вызвать функцию до того как она была объявлена
// Пример

// sayHi();

// function sayHi() {
//   alert('Привет');
// }

// при первом чтении js видит какие объявлены переменные и какие функции объявлены через 
// function declaration и эти функции он считывает полностью именно поэтому мы можем запустить 
// sayHi до того как она описана в коде

// + function declaration - код короче, лаконичнее.
// + fd мы можем описать сначала работу программы а ниже описать те функции которые нам нужны 
// т.e. разделение труда

// Когда мы используем function expression мы не можем вызвать функцию перед тем как мы её описали

// sayHi(); --- Ошибка! ---

// const sayHi = function() {
//       console.log('привет');           
// }

// + fe - если функция где-то вызывается значит она объявлена где-то выше (более строгий подход)

//                         Параметры и аргументы для функции

// Параметр это то значение которое функция будет принимать в себя на запуске
// и это значение она будет использовать внутри себя для работы функции.
   
   function hi(name) {
      console.log(`Привет, ${name} ! How are u?`);
   }

   hi('ilia');
// в данном случае параметром является "name" объявлять переменную name - не нужно
// name - параметр
// ilia - аргумент! т.е. когда мы вызываем функцию место параметра занимает аргумент.

// можем вызывать функцию несколько раз и каждый раз передавать в функцию новое значение
   hi('ivan');
   hi('igor');

// в данных случаях выше мы создавали функцию которая что-то выводит в консоль
// return - это когда функция после вывода возвращает нам какое-то значение

//                              Return

// a and b - are some numbers
// a and b - are parametrs
// 10 and 15 - are arguments
// аргументы становятся на места параметров - соответственно

// function summ(a, b) {
//     const result = a + b; 
//     console.log(result);
// }

// summ(10, 15); 

// но если вызвать функцию summ в консоли то мы увидим undefined 
// по умолчанию любая функция возвращает undefined если не определено что именно она должна возвращать
// т.е. в данный момент функция выводит значение в консоль, но ничего не возвращает

// для того чтобы функция возвращала значение используется return

//  function summ(a, b) {
//      const result = a + b; 
//      return result;
//  }

//  summ(10, 15); 

// в данный момент в консоли высвечивается значение 25, но не возвращается, потому что пока некуда)
// создаем новую переменную чтобы результату было куда возвращаться

//  function summ(a, b) {
//      const result = a + b; 
//      return result;
//  }

//  let res = summ(10, 15); 

//  console.log(res);  и выведем res в консоль и увидим там 25

// значение возвращается именно на место вызова функции и затем оно записывается в переменую res

//  function summ(a, b) {
//    console.log("start");    --- старт в консоли видим
//    const result = a + b; 
//    return result;           --- как только функция встретила return дальше ничего не происходит
//    console.log("finish");   --- финиш уже в консоли не видим после return код никогда не будет достигнут
// }   


// всё что после return в функции - не сработает

//                            Функции как аргумент

   // function summ(a, b) {
   //    const result = a + b; 
   //    return result;
   // }

// код выше можно сократить

// function summ(a, b) {
//       return a + b;
// }

// мы можем передавать функции как аргумент в другие функции
// Пример:

// let res = summ(10, 15);
// console.log(res);

// в консоль можно сразу передать функцию

// console.log(summ(10, 15));

// в данном случае js сначала видит summ(10, 15) смотрит на значения в скобках и производит вычисление
// и только после вычисления выводит в консоль лог полученный результат

// Пример посложнее

// function summ(a, b) {
//        return a + b;
//  }

// const resultss = summ(summ(15, 15), summ(20, 20))
// console.log(resultss);

// в консоли 70. механизм работы:
// интерпретатор идёт сверху вниз, находит переменную resultss видит что она равна вызову функции summ
// смотрит какой первый аргумент, первым аргументом тоже является вызов функции summ
// поэтому сначала выполняется первый аргумент summ с результатом в 30
// 30 возвращается в return если бы в функции не было return а например вывод в консоль то
// вернулось бы значение undefined и на том бы и закончилось)
// после того как в resultss возвращается 30, выполняется второй аргумент summ c результатом в 40
// после этого получаем const resultss = summ(30, 40) и функция запускается еще раз 
// и в итоге получаем 70
// таким образом функции могут передаваться в другие функции в качестве аргументов

// Пример еще сложнее
// когда мы передаем функцию в качестве аргумента в другую функцию и она будет запущена
// в данном случае ниже функция do принимает в качестве аргумента другую функцию
// и мы предполагаем что ту функцию func которую мы передаем в качестве аргумента (или параметра?) 
// что мы запустим ее в этой же функции

function summ(a, b) {
           return a + b;
     }

function diff(a, b) {
      return a - b;
}

function doSomething(func) {    
   let x = 10;
   let y = 15;
   let resul = func(x, y);
   console.log(resul);
}                           // the same      // function doSomething(func) {    
                                             //    let resul = func(10, 15);
                                             //    console.log(resul);                                             
 doSomething(summ);
 doSomething(diff);

// что произошло выше
// doSomething вызывает функцию summ которое приходит в func
// таким образом получается call back 
// функция которая будет вызвана где-то внутри функции после определенных действий
// то есть функция обратного вызова которую мы вызовем позже другой функцией
// 
// вызываем doSomething которое принимает значение summ summ делает работу внутри func
// после этого мы вызываем функцию которую мы туда передали func
// передали х и у запустили получили результат распечатали

// то есть каким-то способом из summ берется действие совершаемое между двумя числами 
// но значение этих числе подставляется из func

// мы запускаем doSomething в качестве аргумента передаем в нее функцию diff
// которая высчитывает разность значения подставляются из x and y 
// после чего получается -5 и это значение уже выводится в консоль

// внутри функции мы определяем параметром что мы будем принимать другую функцию
// и где - то внутри кода её запустим, она выполнится, вернёт результат и он уйдет в консоль

//                          Самовызывающаяся функция iife ES5

// iife i - immediately 
//      i - involved
//      f - function
//      e - expression

// iife - незамедлительно вызывающееся функциональное выражение (самовызывающаяся функция
// то есть функция которая вызывает саму себя) так же известная как 
// анонимная самовызывающаяся функция (имя функции можем не давать)

// итак в чём соль, изначально мы работая с функцией делаем что- то подобное 

// function say() {
//    console.log('hi');
// }

// say();

// Но мы можем этого не делать, а вызвать функцию сразу на месте её объявления без say();
// для этого необходимо обернуть её в круглые скобки, и т.о. мы создаём выражение ()
// в js () создают выражение мы делаем тоже самое, 
// сначала выполняется действие внутри скобок, потом за пределами скобок
// в js наше выражение в виде функции заключенной в () может быть запущено на выполнение 
// если мы допишем круглые скобки которые запустят нашу предыдущую функцию описанную в предыдущих ()
// в итоге наша функция запустится то есть мы сразу вызываем say не выписывая его отдельно
// пример

// (function say() {
//    console.log('hi');
// })();

// если у данной функции убрать say, то тогда в консоли будет то же hi но функция будет без имени
// то есть это будет анонимная самовызывающаяся функция
// такой приём может быть полезен когда мы хотим ограничить область видимости 
// если речь идет о старом стандарте ES5

// пример анонимной самовызывающейся функции и ее запуск с передачей в неё аргументов

(function () {
    console.log('hi');
 })();

(function sum (a, b) {
   console.log(a + b);   // превратим её в самовызывающуюся, имя пока оставляем.
})(10, 15); // для передачи значения, указываем значения во вторых () итог в консоли - 25

// если удалить sum в консоли так же будет 25 но функция уже будет анонимной
// убрав консоль лог поставив return и присвоим значение функции переменной 
// и затем выложив это в консоль мы получим те же 25

let resultt = (function sum (a, b) {
   return a + b;   
})(10, 15); 

console.log(resultt);

// когда функция возвращает что-то она возвращает это на место функции если 
// мы дополнительно ничего не указываем, поэтому в примере выше мы присваиваем 
// вернувшееся после let значение переменной resultt
// т.о. значение после вычисления функции возвращается в переменную resultt

//                                  Стрелочные функции ES6

//   function saidhi(name) {
//    console.log(`Привет, ${name} ! How are u?`);
// }

// пример выше это function declaration
// тоже самое в виде стрелочной функции
// создаём переменную и в неё записываем стрелочную функцию
// у стрелочной функции круглые скобки для параметра функции, затем => затем {} для блока кода
// который будет выполнятсья в стрелочной функции
// стрелочная функция работает так же как и обычная функция, но есть ньюансы

   // function saidhi(name) {
   //    console.log(`Привет, ${name} ! How are u?`);
   // }

   // saidhi('ilai'); 

   // const arrSayHi = (name) => {
   //    console.log(`Привет, ${name} ! How are u?`);
   // }

   // arrSayHi('ilai'); 

// в примере выше видим что у двух разных функций одинаковый результат в консоли
// стрелочная функция не имеет своего контекста и она заимствует контекст из области или
// ссылается на тот же контекст на который ссылается и область в которой она была объявлена
// функция не имеет своего this и ссылается на тот же контекст который имеется в области где 
// она была объявлена

//    Сокращение стрелочной функции

// если стрелочная функция, состоит из 1-й строки и это то значение которое она возвращает, то
// то мы можем не писать фигурные скобки, а сразу после стрелки продолжить писать строчку 
// функции, того что будет выполнятьсья

   // const arrSayHi = (name) => {
   //    console.log(`Привет, ${name} ! How are u?`);
   // }

   // arrSayHi('ilai'); 

   const arrSayHi = (name) => console.log(`Привет, ${name} ! How are u?`);
   arrSayHi('ilai'); 

   function ssum(a, b) {
      const resultat = a + b;
   }

// в виде стрелочной функции это будет вот так:

   // const sSum = (a, b) => {
   //    const resultats = a + b;
   //    return resultats;
   // };

// это можно сократить до 

   // const sSum = (a, b) => {
   //    return a + b;
   // };
 
// но так как у нас стрелочная функция и одна стррока, то можем сократить ещё

   const sSum = (a, b) => a + b;

// вызываем sSum

   const rez = sSum(10, 30);

   console.log(rez);

//                            Массивы - Arrays

// Массивы - это структуры данных. Коробка с кучей фишек (Коллекция)

// Переменная это коробка в которую мы положили какое-то значение, 
// и это значение может быть хоть строкой, числом или true / false или функцию function expression

// Массивы - это коробка с кучей фишек (Коллекция)
// Пример: 

// Перед нами стоит задача описать бренды автомобилей:

   const autoBrand1 = 'Audi';
   const autoBrand2 = 'BMW';
   const autoBrand3 = 'Mazda';
   const autoBrand4 = 'Toyota';

// так как запись выше слишком громоздкая, для её сокращения и придумали массив,
// то есть коллекцию из в данном случае автомобильных брендов

// Шаг 1 

// Создаём константу autoBranbs

// const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota']; //и говорим что она будет равна массиву, то есть []; - массив
                                    // внутри [] элементы распологаются через запятую и пробел между собой
// console.log(autoBrands);

// элементы в массиве имеют свои индексы по которым мы можем обратиться к каждому элементу
// если нужно вывести только Audi, то

// console.log(autoBrands[0]); // чтобы обратиться к элементу массива обращаемся по его индексу в массиве
                            // индексы в массиве начинаются с 0

// у массива есть такое свойство как length
// которое нам возвращает длину массива, то есть количество элементов
// то есть мы можем обратиться к массиву и узнать его length

// console.log(autoBrands.length); // ответ 4

// так же написав в консоли autoBrands - мы увидим массив
// написав в консоли autoBrands.length - мы увидим значение length для данного массива.

// Элементами массива могут быть цифры, true / false(логические значения) или другие массивы
// Вложенные массивы обозначаются так же [] например
// const autoBrands = ['Audi', 'BMW', true, ['Mazda', 'Toyota'], 70];
// вложенные массивы делать не рекомендуется, массив должен содержать однородные элементы и
// его имя должно это отображать

//                           Методы массивов

// Некоторые из них

// .push(), .pop(), .shift(), .unshift(), .splice(), .slice(), forEach(), .indexOf(), .includes()

// Методы массивов которые связаны с добавлением елементов

// Предполагаем что под переменной arr у нас записан некий массив
//          arr.push() - добавляет элемент в конец массива
//          arr.pop() - удалить элемент из конца массива
//          arr.shift() - удалить элемент из начала массива
//          arr.unshift(...items) - Добавить элемент в начало массива
//          arr.splice([start]], [deleteCount, newElements]) - мы можем удалять элемент из массива 
//          или несколько элементов с помощью метода splice
//          arr.slice - вырезает часть массива и возвращает его

// Пример:                   Метод push

// const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota']; 
// console.log(autoBrands); // консоль (4) ['Audi', 'BMW', 'Mazda', 'Toyota']

// Задача добавить в массив ещё один элемент
// Обращаюсь к массиву autobrands вызываю метод push и добавляю новый элемент 'Nissan'

// autoBrands.push('Nissan');
// console.log(autoBrands); // консоль (5) ['Audi', 'BMW', 'Mazda', 'Toyota', 'Nissan']

// особенность примера выше не смотря на const изменение прошло успешно, хотя по идее должна быьт ошибка
// дело в том что массивы и объекты,  когда мы их используем и записываем в переменные
// то переменная не является полноценно этим массивом
// происходит следующее, в области памяти нашей программы образуется массив
// ['Audi', 'BMW', 'Mazda', 'Toyota'] и когда мы говорим что 
// const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota']; то на самом деле 
// переменная const ссылается на этот массив ['Audi', 'BMW', 'Mazda', 'Toyota'];
// который находится в области памяти
// тот факт что это константа означает что данная переменная ссылается только на этот массив
// autoBrands = [1, 2, 3]; --- Ошибка ---
// если мы скажем что эта const будет ссылаться на другой массив то мы получим ошибку
// но с этим массивом ['Audi', 'BMW', 'Mazda', 'Toyota']; мы можем работать как угодно
// добалвять в него значения убирать вырезать и т.д.
// значения массивов и объектов передаются по ссылке
// т.е. 

// let array2 = autoBrands;

// если мы проверим в консоли равны ли эти массивы, то мы увидим true
// array2 ссылается на autoBrands который ссылатеся на массив ['Audi', 'BMW', 'Mazda', 'Toyota', 'Nissan']
// т.е. обе переменные ссылаются на один и тот же массив
// поэтому при сравнении они равны  array2 == autoBrands - true

// но если array2 будет напрямую ссылаться на массив ['Audi', 'BMW', 'Mazda', 'Toyota', 'Nissan']
// let array2 = ['Audi', 'BMW', 'Mazda', 'Toyota', 'Nissan'];
// то при сравнении array2 == autoBrands - false
// то есть autoBrands ссылается на один массив в области памяти
// array2 ссылается на другой массив в области памяти
// и не важно что эти массивы одинаковые по содержанию

//                    Метод splice

// целью метода является удаление элемента из массива
// const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota'];
// autoBrands.push('Nissan');
// autoBrands.splice(2, 1);
// console.log(autoBrands);
// консоль - (4) ['Audi', 'BMW', 'Toyota', 'Nissan']

// 1 аргумент autoBrands.splice(2, 1); говорит с какого индекса стартовать и указатель становится перед этим индексом
// ['Audi', 'BMW', 'Mazda', 'Toyota', 'Nissan'] то есть если 2 то указатель становится перед 'Mazda'
// 2 аргумент говорит какое количество я хочу удалить, то есть если 1 то Mazda будет удалена
// и после этого удаления останется:
// ['Audi', 'BMW', 'Toyota', 'Nissan'];
// если autoBrands.splice(2, 2); то ['Audi', 'BMW','Nissan'] т.е. 
// стартуя со второго индекса удали 2 элемента

//                                       Циклы

// Циклы нужны чтобы выполнять какую-либо практическую операцию n количество раз
// чтобы не вызывать одну и ту же функцию 10 раз
// мы можем поместить ей внутрь цикла и задать команду на запуск этого кода 10 раз
// то есть цикл можно представить как совокупность операций по выполнению 
// ранее описанного задания

// так же циклы нужны для обхода массивов

//                        Цикл For

// for () {

// }

// в круглых скобках () через точку с запятой мы описываем три значения

// Значение 1 
// указываем начальное значение счетчика let i = 0; 
// описываем счётчик который будет регулировать наш цикл
// от этого счётчика зависит сколько раз будет работать цикл
// обычный счётчик объявляется через переменную с именем i
// i - cчётчик, i - итератор, всегда i 

// Значение 2 
// Пишем условие при выполнении которого цикл будет работать: i < 10;
// то есть пока i меньше 10 цикл будет выполняться,
// как только i станет равно или больше 10 цикл остановит своё выполнение
// произойдёт выход из цикла и программа пойдёт работать дальше

// Значение 3
// Указываем то, как будет изменяться значение i после каждой итерации цикла
// у нас она будет увеличиваться на единицу поэтому i++ 
// в таком случае к переменной будет добавлена единица

// итого

// for (let i = 0; i < 10; i++) {
//       console.log(i);
// }

// теперь в теле цикла напишем код который будет выполняться каждый раз когда код будет запускаться    
// выведем в консоль счётчик i
// в консоли увидим 0 1 2 3 4 5 6 7 8 9

// Пример

console.log('strats');

for (let i = 0; i < 10; i++) {
      console.log(i);
}

console.log('finish');

// в консоли увидим starts 0 1 2 3 4 5 6 7 8 9 finish

// программа выше работает сл. образом
// js считывает код доходит до консоль лог старт, выводи в консоль лог старт
// потом видит цикл, запускается проверка, 
// на старте счётчик i равен 0 далее идёт проверка
// 0 < 10? да поэтому значение будет true, т.е. for (let i = 0; true; i++) (вечный цикл)
// пока в цикле true, цикл будет выполняться, если написать просто true
// то он будет выполняться бесконечно, 
// важно писать цикл так чтобы он в какой-то момент завершил своё выполнение
// и произошёл выход из цикла
// пока i = 0, пока i < 10 выполняем блок кода
// console.log(i); первое значение 0, после выполнения блока кода срабатывает итератор i++
// где проходит команду на увеличение i на единицу 0 + 1 = 1 
// опять идёт проверка 1 < 10 значит выполняем блок кода выводим в консоль 1
// далее опять итератор прибавляет 1 и цикл повторяется пока не дойдём до 9-ки
// 9 < 10 да, выводим в консоль лог 9, 9 + 1 = 10 
// 10 < 10 ? нет 10 = 10 но не меньше, соответственно условие не верно false
// т.е. for (let i = 0; false; i++) (вечный цикл) происходит выход из цикла блок кода не запускается
// далее программа работает дальше и мы видим в консоли finish

// так же мы можем написать не i++ а i = i + 2 

// console.log('strats');

// for (let i = 0; i < 10; i = i + 2) {
//       console.log(i);
// }

// console.log('finish');

// мы можем изменить условие когда i будет <= 10 и тогда в консоли мы увидим 10

// console.log('strats');

// for (let i = 0; i <= 10; i = i + 2) {
//       console.log(i);
// }

// console.log('finish');

// Зачем нам нужен цикл? Практическое применение цикла.

// Запустить какой-то блок кода несколько раз
// чтобы записать функцию которой надо запуститься 5 раз 
// мы можем написать 

// console.log('strats');
//for (let i = 0; i < 5; i++) {
//   console.log(i);
// }
// console.log('finish');
// консоль 0, 1, 2, 3, 4, 

//                                Обход массива циклом for

// const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota'];
// чтобы вывести элементы массива по очереди 
// мы обращались к элементу массива по его очереди
// console.log(autoBrands[0]);
// console.log(autoBrands[1]);
// console.log(autoBrands[2]);
// console.log(autoBrands[3]);

// таким образом мы може вывести все элементы массива просто обращаясь к ним по индексу 
// увеличивая его на единицу
// то есть мы можем использовать цикл for для того чтобы с помощью него обойти этот массив
// а индексом у нас будет переменная i 

// то есть 
// цикл будет выполнятсья пока i меньше чем длина массива

// for (i = 0; i < 4; i++ ) {
//      console.log(i);
// }

// таким образом мы вывели цикл который выведет для нас переменную i 5 раз от 0 до 4-х

// так же мы можем выводить здесь элементы массива
// вместо индекса console.log(autoBrands[3]); вместо числа 0 1 или 3 мы подставим переменную i
// наш счётчик который итак увеличивается от 0 до 3 -х

// for (i = 0; i < 4; i++ ) {
//      console.log(autoBrands[i]);
// }

// таким образом мы запускаем цикл 4 раза и выводим наш массив autoBrands
// передавая сюда переменную i которая меняет своё значение
// т.е. каждый раз наша переменная i сначала равна 0 потом она равна 1 потом 2 потом 3
// таким образом мы можем обойти массив

// Если количество элементов массива большое то лучше написать не i < 4 а autoBrands.length

// for (i = 0; i < autoBrands.length; i++ ) {
//      console.log(autoBrands[i]);
// }

// то етсь мы подставили длину элемента массива количество элементов в массиве а так как элементов 4
// то в консоли мы увидим все элементв массива autoBrands и соответственно если массив изменит 
// количество элементов то цикл менять будет не нужно

// таким образом везде где по индексу можно обращаться к элементам там мы можем обходить массив циклом for

//                                     Обход массива циклом for (of)

// const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota'];

// for (let item of autoBrands) {
//    console.log(autoBrands);
// }                                    --- цикл for of ---

// в консоли увидим Audi BMW Mazda Toyota

// массив будет пройден столько раз, сколько в нём элементов и мы говорим что в момент прохождения 
// по массиву мы будем создавать переменную item, то есть каждый раз переменная item будет равна
// одному из элементов массива который мы обходим autoBrands

// в примере выше мы говорим, для массива autoBrands и на каждой итерации(повторение какого-либо действия)
// каждый элемент массива поочереди будет записан в переменную item
// let item of autoBrands, то есть каждый элемент будет записан поочереди в переменную item
// и в каждом цикле каждой итерации мы к ней обращаемся
// переменная item может называться как угодно item (просто наиболее общепринятое имя)
// можно использовать наиболее подходящее имя по смыслу

//                                      Обход массива методом forEach ()

// У массивов (не у всех массивоподобных а именно у массивов)

// Задача обойти массив методом forEach

// обращаемся к массиву autoBrands далее точка и указываем метод forEach. 
// Данный метод forEach принимает в качестве аргумента функцию function(){} которая будет выполнена 
// для каждого элемента массива поочереди, и в этой функции параметром мы можем объявить элемент
// значение элемента Массива и его индекс, если объявить только одно значение в () то это будет элемент
// то есть если это будет только item то это будет элемент, объявляем каждый элемент как item и
// выводим в консоль

const autoBrands = ['Audi', 'BMW', 'Mazda', 'Toyota'];

// autoBrands.forEach(function(item){
//    console.log(item);  
// })  в консоли увидим Audi BMW Mazda Toyota

// так же через запятую можем объявить второй параметр в этой функции index
// autoBrands.forEach(function(item, index) то есть на его место будет передан индекс каждого элемента
// то есть в консоль мы можем вывести console.log(`&{item} => &{index}`);

autoBrands.forEach(function (item, index) {
   console.log(`${item} => ${index}`);
}) // в консоли увидим  //Audi => 0
                        //  BMW => 1
                        //  Mazda => 2
                        //  Toyota => 3

// item - значение элемента, второй парамент - index
// вместо item и index можем писать что угодно
// таким образом мы можем обойти массив методом forEach и вывести все его элементы
// в forEach мы можем передать функцию не только так как выше, 
// можем описать функцию в другом месте и передать ее сюда, а можем передать сюда стрелочную функцию
// Рассмотрим вариант где мы опишем функцию рядом

/*
 function printBrand(brand, i) {
   console.log(`${brand} => ${i}`);
})

функция printBrand которая должна использоваться как функция обработчик для каждого элемента массива
обращаемся к массиву autoBrands вызываем метод .forEach() и передаём туда функцию printBrand

autoBrands.forEach(printBrand); - после printBrand нет круглых скобок потому что функция попадает 
как аргумент внутрь

в консоли тот же результат  //Audi => 0
                            // BMW => 1
                            // Mazda => 2
                            // Toyota => 3

То есть функцию можно передать вот так

autoBrands.forEach(function (item, index) {
   console.log(`${item} => ${index}`);
}) // в консоли увидим  //Audi => 0
                        //  BMW => 1
                        //  Mazda => 2
                        //  Toyota => 3   - описав функцию

если функция описана где-то отдельно мы просто передаём её название
*/

/*

*/
